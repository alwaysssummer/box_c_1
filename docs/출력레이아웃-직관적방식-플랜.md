# 출력 레이아웃 - 직관적 방식 구현 플랜

## 핵심 개념

### 기존 방식 (복잡함)
```
[출력 템플릿 관리] → [문제 유형에서 선택]
- 별도 화면에서 레이아웃 생성
- 문제 유형에서 드롭다운으로 연결
- 연결이 끊어지기 쉬움
```

### 새로운 방식 (직관적)
```
[문제 유형 설정 화면에서 모든 것을 한 번에]
- 데이터 소스에서 블록 자동 감지
- 프레임에 블록 직접 배치 (시각적 UI)
```

---

## 구현 단계

### Phase 1: 블록 자동 감지 시스템

#### 1.1 원큐 방식 (추출 데이터 기반)
```typescript
// 프롬프트의 output_schema에서 블록 추출
const detectBlocksFromPrompt = (promptId: string) => {
  // 프롬프트 조회 → output_schema 분석
  // 표준 블록: instruction, body, choices, answer, explanation
  return ['instruction', 'body', 'choices', 'answer']
}
```

#### 1.2 슬롯 방식 (생성 데이터 기반)
```typescript
// required_slots에서 블록 추출
const detectBlocksFromSlots = (questionType: QuestionType) => {
  // question_type_items의 data_types 조회
  // 각 data_type의 output_slots 병합
  return ['passage', 'question', 'givenBox', 'choices']
}
```

### Phase 2: 프레임 설정 UI

#### 2.1 문제 유형 폼에 통합
```
┌─────────────────────────────────────────────────────┐
│  5. 출력 프레임 설정                                │
├─────────────────────────────────────────────────────┤
│  레이아웃: ○ 1단  ● 2단                            │
│                                                     │
│  ┌─ 프레임 미리보기 ─────────────────────┐         │
│  │  ┌───────────┬───────────┐           │         │
│  │  │ [지문 ▼] │ [문제 ▼] │           │         │
│  │  │           │           │           │         │
│  │  └───────────┴───────────┘           │         │
│  └───────────────────────────────────────┘         │
│                                                     │
│  🔄 감지된 블록: 지문, 문제, 선택지, 정답           │
└─────────────────────────────────────────────────────┘
```

#### 2.2 블록 드롭다운 옵션
- 데이터 소스에서 자동 감지된 블록만 표시
- 수동으로 추가 가능한 "직접 입력" 옵션

### Phase 3: 데이터 저장 구조

#### 3.1 question_types 테이블 확장
```sql
-- 기존 print_layout_id 제거 (외부 참조 방식)
-- 대신 프레임 설정을 직접 저장
ALTER TABLE question_types
ADD COLUMN frame_config JSONB DEFAULT '{}';

-- frame_config 구조
{
  "layout": "2-column",  // "1-column" | "2-column"
  "cells": {
    "left": ["passage"],
    "right": ["question", "choices"]
  },
  "style": {
    "fontSize": 10,
    "lineHeight": 1.6
  }
}
```

### Phase 4: 렌더링 연동

#### 4.1 teacher 페이지에서 frame_config 사용
```typescript
// 문제 유형의 frame_config를 직접 사용
const layout = questionType.frame_config || DEFAULT_FRAME_CONFIG

// 블록 생성 (데이터 → 블록 변환)
const blocks = convertToBlocks(questions, layout.cells)

// 렌더링
<PrintDocument blocks={blocks} layout={layout} />
```

---

## 상세 구현 계획

### Step 1: 블록 감지 유틸리티 (src/lib/print-system/block-detector.ts)
- `detectBlocksFromPrompt(promptId)` - 원큐용
- `detectBlocksFromSlots(questionTypeId)` - 슬롯용
- `getAvailableBlocks(questionType)` - 통합

### Step 2: 프레임 설정 컴포넌트 (src/components/features/question-type/FrameConfigEditor.tsx)
- 레이아웃 선택 (1단/2단)
- 프레임 시각적 편집기
- 블록 드롭다운 (자동 감지된 블록)
- 스타일 설정 (글꼴, 줄간격)

### Step 3: PromptBasedForm 수정
- `FrameConfigEditor` 통합
- `frame_config` 저장/로드

### Step 4: API 수정
- `question_types` CRUD에 `frame_config` 추가
- DB 마이그레이션

### Step 5: teacher 페이지 수정
- `frame_config` 기반 렌더링

---

## 블록 타입 정의

### 지문형 (Passage)
| 블록 | 설명 | 데이터 소스 |
|------|------|-------------|
| passage | 지문 본문 | body |
| question | 문제 (지시문+본문) | instruction + body |
| choices | 선택지 | choices |
| answer | 정답 | answer |
| explanation | 해설 | explanation |
| givenBox | 주어진 글 (순서/삽입) | givenBox |

### 문장형 (Sentence)
| 블록 | 설명 | 데이터 소스 |
|------|------|-------------|
| original | 원문 | sentences.original |
| translation | 해석 | sentences.translation |
| vocabulary | 어휘 | sentences.vocabulary |
| grammar | 문법 | sentences.grammar |
| structure | 구문 분석 | sentences.structure |

---

## 예상 결과

### Before (현재)
1. 설정 > 출력 템플릿 → 레이아웃 생성
2. 설정 > 문제 유형 → 레이아웃 선택 (드롭다운)
3. 연결 오류 발생 가능

### After (새로운 방식)
1. 설정 > 문제 유형 → 프레임 설정 (한 화면에서)
2. 블록 자동 감지 → 드래그&드롭 or 드롭다운 선택
3. 즉시 미리보기 가능


